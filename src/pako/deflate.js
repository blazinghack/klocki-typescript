'use strict';


var zlib_deflate = require('./zlib/deflate');
var utils        = require('./utils/common');
var ZStream      = require('./zlib/zstream');

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var _Z_NO_FLUSH      = 0;
var _Z_FINISH        = 4;

var _Z_OK            = 0;
var _Z_STREAM_END    = 1;
var _Z_SYNC_FLUSH    = 2;

var _Z_DEFAULT_COMPRESSION = -1;

var _Z_DEFAULT_STRATEGY    = 0;

var _Z_DEFLATED  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `_Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `_Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (_Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `_windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: _Z_DEFAULT_COMPRESSION,
    method: _Z_DEFLATED,
    chunkSize: 16384,
    _windowBits: 15,
    memLevel: 8,
    strategy: _Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt._windowBits > 0)) {
    opt._windowBits = -opt._windowBits;
  }

  this.err    = 0;      // error code, if happens (0 = _Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this._strm = new ZStream();
  this._strm._avail_out = 0;

  var status = zlib_deflate._deflateInit2(
    this._strm,
    opt.level,
    opt.method,
    opt._windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== _Z_OK) {
    throw new Error(msg[status]);
  }

}

/**
 * Deflate#push(data[, _mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - _mode (Number|Boolean): 0..6 for corresponding _Z_NO_FLUSH..Z_TREE _modes.
 *   See constants. Skipped or `false` means _Z_NO_FLUSH, `true` means _Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * _mode _Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use _mode _Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, _mode) {
  var _strm = this._strm;
  var chunkSize = this.options.chunkSize;
  var status, __mode;

  if (this.ended) { return false; }

  __mode = (_mode === ~~_mode) ? _mode : ((_mode === true) ? _Z_FINISH : _Z_NO_FLUSH);

  // Convert data if needed
  if (toString.call(data) === '[object ArrayBuffer]') {
    _strm._input = new Uint8Array(data);
  } else {
    _strm._input = data;
  }

  _strm._next_in = 0;
  _strm._avail_in = _strm._input.length;

  do {
    if (_strm._avail_out === 0) {
      _strm.output = new utils.Buf8(chunkSize);
      _strm._next_out = 0;
      _strm._avail_out = chunkSize;
    }
    status = zlib_deflate._deflate(_strm, __mode);    /* no bad return value */

    if (status !== _Z_STREAM_END && status !== _Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (_strm._avail_out === 0 || (_strm._avail_in === 0 && (__mode === _Z_FINISH || __mode === _Z_SYNC_FLUSH))) {
      this.onData(utils.shrinkBuf(_strm.output, _strm._next_out));
    }
  } while ((_strm._avail_in > 0 || _strm._avail_out === 0) && status !== _Z_STREAM_END);

  // Finalize on the last chunk.
  if (__mode === _Z_FINISH) {
    status = zlib_deflate._deflateEnd(this._strm);
    this.onEnd(status);
    this.ended = true;
    return status === _Z_OK;
  }

  // callback interim results if _Z_SYNC_FLUSH.
  if (__mode === _Z_SYNC_FLUSH) {
    this.onEnd(_Z_OK);
    _strm._avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (_Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (_Z_FINISH) or should be flushed (_Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === _Z_OK) {
    this.result = utils.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this._strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - _windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative _windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}

exports.deflate = deflate;
